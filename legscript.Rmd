---
title: "Legendary Setup"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
```

## 0. Read files

```{r input}
library(tidyverse)
library(magrittr)
setwd("D:/Mathias/legendary/new versions")
heroes=read_csv('heroes.csv')
schemes=read_csv('schemes.csv')
villains=read_csv('villains.csv')
henchmen=read_csv('henchmen.csv')
masterminds=read_csv('masterminds.csv')
src = list(heroes,schemes,villains,henchmen,masterminds)
names(src) = c("heroes","schemes","villains","henchmen","masterminds")
```

The function `genFun` requires only a `src` list as compiled in the input chunk. It also allows the optional arguments:

* `playerc`: Number of players (2-5). Default is 2. Playing solo is currently not supported.
* `epic`: Allow randomly picking the epic version of a mastermind (if any). Set to -1 to enable this. This only influences the traits in the returned list. Default is 0.
* `fixedMM`: Enter the exact name for a mastermind to restrict the random generator. Default is 0.
* `fixedSCH`: Enter the exact name for a scheme to restrict the random generator. The 'exact' names in the source data do need some clean-up, so this will often break. Default is 0.
* `fixedHM`: Enter the exact name for one or more henchmen groups (in a vector if more than one) to restrict the random generator. Default is NULL.
* `fixedHER`: Enter the exact name for one or more heroes (in a vector if more than one) to restrict the random generator. If a hero exists with the same hero name in multiple sets, a random set is selected. Default is NULL.
* `fixedVIL`: Enter the exact name for one or more villain groups (in a vector if more than one) to restrict the random generator. Default is NULL.

Requirements for the selected mastermind and/or scheme take precedent over optional henchmen, villains or heroes. If too many names are provided for an argument, order of entry takes precedent.

Mismatches with the source data will spawn warnings and lead to the restriction being ignored.

The function returns a list with the following contents:

* `Scheme`: Name of the scheme.
* `Mastermind`: Name of the mastermind. It will additionally say "epic" if traits for the epic version were returned.
* `Villains`: Names of the villain groups.
* `Henchmen`: Names of the henchmen groups.
* `Heroes`: Names of the heroes.
* `Heroes_set`: Set IDs for the selected heroes, to disambiguate recurring heroes in multiple sets.
* `scores`: A list with the scores in separate date frames for each of the above. For metadata of the scores, check
source documentation.
* `sets`: The sets of the scheme, mastermind, villains, henchmen and heroes. This can be used to reject generated setups if unowned or undesired sets are part of them. It can also be used to preferentially pick setups with cards from certain (new) sets.

```{r gameGenFun}
genFun = function(src,
                  playerc=2,
                  epic=0,
                  fixedMM=0,
                  fixedSCH=0,
                  fixedHM=NULL,
                  fixedHER=NULL,
                  fixedVIL=NULL) {
  
  
  #setup numbers depending on number of players
  heroesc = 0
  if (playerc==2) {
    heroesc=5
    villainc=2
    henchc=1
    bystc=2
  }
  if (playerc==3) {
    heroesc=5
    villainc=3
    henchc=1
    bystc=8
  }
  if (playerc==4) {
    heroesc=5
    villainc=3
    henchc=2
    bystc=8
  }
  if (playerc==5) {
    heroesc=6
    villainc=4
    henchc=2
    bystc=12
  }
  if (epic==-1) {
    epic = sample(0:1,1) #0 is still not epic!
  }
  if (heroesc==0) {
    stop("invalid player count")
  }
  
  
  ##############################################################
  ##Generate a scheme
  schnumber = 0
  
  #Fixed scheme given?
  if (fixedSCH!=0) {
    schnumber = match(fixedSCH,src$schemes$Name)
    if (is.na(schnumber)) {
      warning("Scheme - ",fixedSCH," - not found")
    }
  }
  
  #Random scheme if not given or not found
  if (fixedSCH==0|is.na(schnumber)) {
    schnumber = sample(1:nrow(src$schemes),1)
  }
  
  #save name and scores
  schem = src$schemes$Name[schnumber]
  schemtraits = filter(src$schemes,Name==schem)
  
  #set NA's to 0 (can be important for metrics)
  schemtraits[is.na(schemtraits)]=0
  
  #playerc dependent scheme settings:
  if (grepl(":",
            src$schemes$HC[schnumber],
            fixed=T)) {
    schemeset = strsplit(src$schemes$HC[schnumber],
                         split=":|;")
    schemeset_nrs = tibble(playerc=seq(1,(length(schemeset[[1]])/2)),
                           n=seq(1,(length(schemeset[[1]])/2)))
    j=0
    for (i in dim(schemeset_nrs)[1]) {
      j = j + 1
      schemeset_nrs$playerc[i] = as.numeric(schemeset[[1]][j])
      schemeset_nrs$n[i] = schemeset[[1]][j+1]
      j = j + 1
    }
    schemeset_nrs %<>% filter(playerc<=playerc)
    if (dim(schemeset_nrs)[1]==1) {
      src$schemes$HC[schnumber]=schemeset_nrs$n[1]
    }
    if (dim(schemeset_nrs)[1]>1) {
      src$schemes$HC[schnumber]=schemeset_nrs$n[schemeset_nrs$playerc==max(schemeset_nrs$playerc)]
    }
  }
  
  #modify card numbers according to scheme
  heroesc = heroesc + ifelse(!is.na(src$schemes$HC[schnumber]),
                             as.numeric(src$schemes$HC[schnumber]),
                             0)
  villainc = villainc + ifelse(!is.na(src$schemes$VC[schnumber]),
                               src$schemes$VC[schnumber],
                               0)
  henchc = henchc + ifelse(!is.na(src$schemes$CH[schnumber]),
                           src$schemes$CH[schnumber],
                           0)
  
  
  ##############################################################
  ##Generate a mastermind
  
  #Only list the individual masterminds
  #not tactics (with a MM value), not epic versions, not transformed versions (T)
  mmlist=filter(src$masterminds,
                is.na(MM),
                is.na(Epic),
                is.na(T))
  mmnumber = 0
  
  #Fixed mm given?
  if (fixedMM!=0) {
    mmnumber = match(fixedMM,mmlist$Name)
    if (is.na(mmnumber)) {
      warning("Mastermind - ",fixedMM," - not found")
    }
  }
  
  #Random mm
  if (fixedMM==0|
      is.na(mmnumber)) {
    mmnumber = sample(1:nrow(mmlist),1)
  }
  
  #save name and scores
  mm = mmlist$Name[mmnumber]
  mmtraits = filter(src$masterminds,
                    MM==mm|
                      Name==mm)
  
  #set NA's to 0 (can be important for metrics)
  mmtraits[is.na(mmtraits)]=0
  
  #modify the scores for epic or not; add epic label to mm name
  if (epic==0) {
    mmtraits = filter(mmtraits,Epic==0)
  }
  if (epic==1&
      mmtraits$Epic[2]==1) {
    mmtraits = filter(mmtraits,
                      Epic==1|
                        MM!=0)
    mm = c(mm,"epic")
  }
  
  
  
  ##############################################################
  ##Generate villain groups
  villainc2 = villainc #clone to a variable, which can be modified based on required villain group parameters
  villnames = 0 #store fixed names here
  villf = 0 #this int will keep count of nr of fixed variables
  vil = 0 #store random names here
  
  villist=distinct(src$villains,Group) #check on group, not individual card
  
  #Villain group required by scheme?
  if (!is.na(src$schemes$Vill_Inc[schnumber])) {
    villnames[villf+1] = src$schemes$Vill_Inc[schnumber]
    villf = villf + 1
  }
  
  #Villain group required by mm?
  if (!is.na(mmlist$LeadsV[mmnumber])&
      (villainc-villf)!=0&
      mmlist$LeadsV[mmnumber]!=villnames[1]) {
    villnames[villf+1] = mmlist$LeadsV[mmnumber]
    villf = villf + 1
  }
  
  villainc2= villainc - villf #remove the fixed groups from the required number
  
  #fixed villain groups given as function argument?
  if (villainc2!=0&
      length(fixedVIL)>0) {
    for (i in 1:length(fixedVIL)) {
      if (fixedVIL[i]%in%villist$Group) {
        if (!fixedVIL[i]%in%villnames) {
          villnames[villf+1] = villist$Group[villist$Group==fixedVIL[i]]
          villf = villf + 1
        }
      }
      else {
        warning("Villain - ",fixedVIL[i]," - not found")
      }
    }
    
    #check if too many fixed arguments and truncate accordingly
    #e.g. if scheme and mastermind demand too many groups already, function argument value is discarded
    if (length(villnames)>villainc) {
      villnames = villnames[1:villainc]
    }
  }
  villainc2= villainc - villf #remove from required number
  
  #random villain groups
  if (villainc2>0) {
    villist = filter(villist,!Group%in%villnames)
    vil=sample(1:nrow(villist),villainc2,replace=F)
    vil = villist$Group[vil]
  }
  
  #join both random and fixed names
  if (villf!=0) {
    if (vil[1] != 0) {
      vil = c(villnames,vil)
    }
    if (vil[1] == 0) {
      vil = villnames
    }
  }
  #save scores
  viltraits = filter(src$villains,Group%in%vil)
  viltraits[is.na(viltraits)]=0
  
  
  
  
  ##############################################################
  ##Generate henchmen groups
  #similar to villains, see above
  henchc2 = henchc
  henchnames = 0
  henchf = 0
  hench = 0
  
  #only distinct group names due to the Mandarin and his rings
  hmlist=distinct(src$henchmen,Name)
  
  if (!is.na(src$schemes$HM_Inc[schnumber])) {
    henchnames[henchf+1] = src$schemes$HM_Inc[schnumber]
    henchf = henchf + 1
  }
  if (!is.na(mmlist$LeadsH[mmnumber])&(henchc-henchf)!=0) {
    henchnames[henchf+1] = mmlist$LeadsH[mmnumber]
    henchf = henchf + 1
  }
  henchc2= henchc - henchf
  if (henchc2!=0&length(fixedHM)>0) {
    for (i in 1:length(fixedHM)) {
      if (fixedHM[i]%in%hmlist$Name) {
        if (!fixedHM[i]%in%henchnames) {
          henchnames[henchf+1] = hmlist$Name[hmlist$Name==fixedHM[i]]
          henchf = henchf + 1
        }
      }
      else {
        warning("Henchmen - ",fixedHM[i]," - not found")
      }
    }
    if (length(henchnames)>henchc) {
      henchnames = henchnames[1:henchc]
    }
  }
  henchc2= henchc - henchf
  if (henchc2>0) {
    henchmen = filter(hmlist,!Name%in%henchnames)
    hench=sample(1:nrow(hmlist),henchc,replace=F)
    hench = hmlist$Name[hench]
  }
  
  if (henchf!=0) {
    if (hench[1] != 0) {
      hench = c(henchnames,hench)
    }
    if (hench[1] == 0) {
      hench = henchnames
    }
  }
  henchtraits = filter(src$henchmen,Name%in%hench)
  henchtraits[is.na(henchtraits)]=0
  
  
  
  ##############################################################
  ##Generate heroes
  fixed_heroes = 0
  heronames = NULL
  
  #A few schemes have such specific needs their hero requirements are hardcoded here separately
  if (schemtraits$Hero_Inc[1]=="CUSTOM") {
    schemtraits$Hero_Inc[1] = NA
    if (schemtraits$Name[1]=="Avengers vs X-Men") {
      teamlist = count(src$heroes,Team)
      teamlist %<>% filter(n>12)
      teamlist %<>% sample_n(2)
      src$heroes %<>% filter(Team%in%teamlist$Team)
      fixedHER = NULL
      src$heroes$uni = paste(src$heroes$Hero,src$heroes$Set,sep="_")
      herolist1 = distinct(filter(src$heroes,Team==teamlist$Team[1]),uni)
      herolist2 = distinct(filter(src$heroes,Team==teamlist$Team[2]),uni)
      heronumber1 = sample(1:nrow(herolist1),heroesc/2,replace=F)
      heronumber2 = sample(1:nrow(herolist2),heroesc/2,replace=F)
      heroid1 = herolist1$uni[heronumber]
      heroid2 = herolist2$uni[heronumber]
      heronames = tibble(heroid=c(heroid1,heroid2))
      heronames$name=NA
      heronames$set=NA
      for (i in 1:heroesc) {
        heronames$name[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][1]
        heronames$set[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][2]
      }
      heroesc = 0
    }
    if (schemtraits$Name[1]=="House of M") {
      fixedHER = NULL
      src$heroes$uni = paste(src$heroes$Hero,src$heroes$Set,sep="_")
      herolist1 = distinct(filter(src$heroes,Team=="X-Men"),uni)
      herolist2 = distinct(filter(src$heroes,Team!="X-Men"),uni)
      heronumber1 = sample(1:nrow(herolist1),4,replace=F)
      heronumber2 = sample(1:nrow(herolist2),2,replace=F)
      heroid1 = herolist1$uni[heronumber]
      heroid2 = herolist2$uni[heronumber]
      heronames = tibble(heroid=c(heroid1,heroid2))
      heronames$name=NA
      heronames$set=NA
      for (i in 1:heroesc) {
        heronames$name[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][1]
        heronames$set[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][2]
      }
      heroesc = 0
    }
  }
  
  #hero required by scheme?
  if (is.na(src$schemes$Hero_Inc[schnumber])==F) {
    fixed_heroes[1] = src$schemes$Hero_Inc[schnumber]
  }
  
  #disambiguate names by concatening set id
  src$heroes$uni = paste(src$heroes$Hero,src$heroes$Set,sep="_")
  herolist = distinct(src$heroes,uni)
  
  #check if the provided fixed names can be found
  fixedHER2 = fixedHER[fixedHER%in%src$heroes$Hero]
  if (length(fixedHER2<length(fixedHER))) {
    warning("Hero(es) ",paste(fixedHER[!fixedHER%in%fixedHER2],collapse=",")," not found.")
  }
  
  #join both the scheme hero and the fixed provided (if any)
  fixed_heroes = c(fixed_heroes,fixedHER2)
  
  #set up name, set, and concatenated unique id ('heroid')
  fixed_heroes = tibble(fixed_heroes)
  fixed_heroes$name = fixed_heroes$fixed_heroes
  fixed_heroes$set = NA
  #remove the dummy row if no hero was part of the sceme requirements
  if (fixed_heroes$name[1]==0) {
    fixed_heroes = fixed_heroes[-1,]
  }
  
  #check required hero count
  heroesc2 = heroesc - dim(fixed_heroes)[1]
  
  #if too many heroes now, truncate
  if (heroesc2<0) {
    fixed_heroes = fixed_heroes[1:heroesc,]
  }
  
  #if any fixed heroes, add proper set. randomize if hero with given name in multiple sets
  if (dim(fixed_heroes)[1]>0) {
    for (i in 1:dim(fixed_heroes)[1]) {
      sets = filter(src$heroes,Hero==fixed_heroes$name[i],Ct==1)
      if (dim(sets)[1]>1) {
        rand = sample(1:dim(sets)[1],1)
        fixed_heroes$set[i] = sets$Set[rand]
      }
      if (dim(sets)[1]==1) {
        fixed_heroes$set[i] = sets$Set[1]
      }
      if (dim(sets)[1]==0) {
        warning(paste0("Data error (hero not found): ",fixed_heroes$name[i]))
      }
    }
  }
  #add unique heroid
  fixed_heroes = select(fixed_heroes,-fixed_heroes)
  fixed_heroes$heroid = paste(fixed_heroes$name,fixed_heroes$set,sep="_")
  
  #fill up with random heroes
  if (heroesc2>0) {
    heronumber = sample(1:nrow(herolist),heroesc2,replace=FALSE)
    heroid = herolist$uni[heronumber]
    heronames = tibble(heroid)
    heronames$name=NA
    heronames$set=NA
    for (i in 1:heroesc2) {
      heronames$name[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][1]
      heronames$set[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][2]
    }
  }
  
  #join
  #only fixed heroes:
  if (is.null(heronames)) {
    heronames = fixed_heroes
  }
  #also random ones:
  if (!is.null(heronames)) {
    heronames = rbind(fixed_heroes,heronames)
  }
  #save scores
  herotraits = filter(src$heroes,uni%in%heronames$heroid)
  herotraits[is.na(herotraits)]=0
  
  #list sets
  sets = c(heronames$set,
           schemtraits$Set,
           mmtraits$Set[1],
           filter(viltraits,!duplicated(Group))$Set,
           filter(henchtraits,!duplicated(Name))$Set)
  
  ##Print out results
  resu = list(
    schem,
    mm,
    vil,
    hench,
    heronames$name,
    heronames$set,
    list(schemtraits,mmtraits,viltraits,henchtraits,herotraits),
    sets)
  names(resu) = c("Scheme",
                  "Mastermind",
                  "Villains",
                  "Henchmen",
                  "Heroes",
                  "Heroes_set",
                  "scores",
                  "sets")
  names(resu$scores) = c("scheme",
                         "mastermind",
                         "villains",
                         "henchmen",
                         "heroes")
  return(resu)
}

```

This chunk generates a list of potential setups. A few 1000 should take less than a minute.

```{r gameGeneration}
#test = genFun(src,epic=-1,fixedHER = c("Captain America","Deadpool","derpsmith jr"))

numberofruns = 100
games=list()
for (i in 1:numberofruns) {
  games[[i]] = genFun(src,epic=0)
}
```

In this chunk a function is used to preferentially select games from certain sets.

* use `setreq` to list set codes you want preferentially. Default is no preference.
* use `reject` to list set codes you want to exclude. Default is no hate.
* use `dropgames` to indicate minimum number of card groups from the preferred sets to be part of the setup. Default is 1.

```{r setGames}
setGames <- function(games,
                     setreq = NULL,
                     reject = NULL,
                     dropgames = 1) {
  goodGames = tibble(setcount = seq(1,length(games)),
                     setdiv = seq(1,length(games)),
                     badgame = seq(1,length(games)))
  for (i in 1:length(games)) {
    setsreqed = match(games[[i]]$sets,setreq)
    setsreqed = setsreqed[!is.na(setsreqed)]
    goodGames$setcount[i] = length(setsreqed)
    goodGames$setdiv[i] = length(setsreqed[!duplicated(setsreqed)])
    
    badgame = match(games[[i]]$sets,reject)
    badgame = badgame[!is.na(badgame)]
    goodGames$badgame[i] = ifelse(length(badgame)==0,0,1)
  }
  
  if (!is.null(setreq)) {
    games = games[goodGames$setcount>dropgames]
    goodGames = filter(goodGames,
                       setcount>dropgames)
  }
  return(games[goodGames$badgame==0])
}

#setreq = c("R","AOS","HOA","NM","D")
setreq = NULL
reject = "GG"
games2 = setGames(games,
                  setreq = setreq,
                  reject = reject,
                  dropgames = 3)

```

This function allows the printing to clipboard of setup information, so it can be pasted in an Excel sheet for keeping track of game results (win/loss, easy or not...).

```{r setupPrint}
setupPrint <- function(game) {
  heroid = paste0(game$Heroes," (",game$Heroes_set,")")
  setup = c(game$Scheme,
            paste(game$Mastermind,collapse=" - "),
            paste(game$Villains,collapse="|"),
            paste(game$Henchmen,collapse="|"),
            paste(heroid,collapse="|"))
  write.table(t(setup),"clipboard",sep="\t",col.names = F,row.names = F)
}

setupPrint(games2[[2]])
```

These lookup functions may be useful in case of uncertainty where to find a hero.

```{r lookups}
setlookup <- function(name,data=src,type="hero") {
  result = paste0(type," not found")
  if (type=="hero") {
    result = paste(filter(src$heroes,Hero==name,Ct==1)$Set,collapse="|")
  }
  if (type=="mastermind") {
    result = filter(src$masterminds,Name==name)$Set[1]
  }
  return(result)
}

teamlookup <- function(name,data=src) {
  result = "hero not found"
  result = paste(filter(src$heroes,Hero==name,Ct==1)$Team,collapse="|")
  return(result)
}

teamlookup("She-Hulk")

```

