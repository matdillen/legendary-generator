src$schemes$HC[schnumber]=schemeset_nrs$n[schemeset_nrs$playerc==max(schemeset_nrs$playerc)]
}
}
#modify card numbers according to scheme
heroesc = heroesc + ifelse(!is.na(src$schemes$HC[schnumber]),
as.numeric(src$schemes$HC[schnumber]),
0)
villainc = villainc + ifelse(!is.na(src$schemes$VC[schnumber]),
src$schemes$VC[schnumber],
0)
henchc = henchc + ifelse(!is.na(src$schemes$CH[schnumber]),
src$schemes$CH[schnumber],
0)
##############################################################
##Generate a mastermind
#Only list the individual masterminds
#not tactics (with a MM value), not epic versions, not transformed versions (T)
mmlist=filter(src$masterminds,
is.na(MM),
is.na(Epic),
is.na(T))
mmnumber = 0
#Fixed mm given?
if (fixedMM!=0) {
mmnumber = match(fixedMM,mmlist$Name)
if (is.na(mmnumber)) {
warning("Mastermind - ",fixedMM," - not found")
}
}
#Random mm
if (fixedMM==0|
is.na(mmnumber)) {
mmnumber = sample(1:nrow(mmlist),1)
}
#save name and scores
mm = mmlist$Name[mmnumber]
mmtraits = filter(src$masterminds,
MM==mm|
Name==mm)
#set NA's to 0 (can be important for metrics)
mmtraits[is.na(mmtraits)]=0
#modify the scores for epic or not; add epic label to mm name
if (epic==0) {
mmtraits = filter(mmtraits,Epic==0)
}
if (epic==1&
mmtraits$Epic[2]==1) {
mmtraits = filter(mmtraits,
Epic==1|
MM!=0)
mm = c(mm,"epic")
}
##############################################################
##Generate villain groups
villainc2 = villainc #clone to a variable, which can be modified based on required villain group parameters
villnames = 0 #store fixed names here
villf = 0 #this int will keep count of nr of fixed variables
vil = 0 #store random names here
villist=distinct(src$villains,Group) #check on group, not individual card
#Villain group required by scheme?
if (!is.na(src$schemes$Vill_Inc[schnumber])) {
villnames[villf+1] = src$schemes$Vill_Inc[schnumber]
villf = villf + 1
}
#Villain group required by mm?
if (!is.na(mmlist$LeadsV[mmnumber])&
(villainc-villf)!=0&
mmlist$LeadsV[mmnumber]!=villnames[1]) {
villnames[villf+1] = mmlist$LeadsV[mmnumber]
villf = villf + 1
}
villainc2= villainc - villf #remove the fixed groups from the required number
#fixed villain groups given as function argument?
if (villainc2!=0&
length(fixedVIL)>0) {
for (i in 1:length(fixedVIL)) {
if (fixedVIL[i]%in%villist$Group) {
if (!fixedVIL[i]%in%villnames) {
villnames[villf+1] = villist$Group[villist$Group==fixedVIL[i]]
villf = villf + 1
}
}
else {
warning("Villain - ",fixedVIL[i]," - not found")
}
}
#check if too many fixed arguments and truncate accordingly
#e.g. if scheme and mastermind demand too many groups already, function argument value is discarded
if (length(villnames)>villainc) {
villnames = villnames[1:villainc]
}
}
villainc2= villainc - villf #remove from required number
#random villain groups
if (villainc2>0) {
villist = filter(villist,!Group%in%villnames)
vil=sample(1:nrow(villist),villainc2,replace=F)
vil = villist$Group[vil]
}
#join both random and fixed names
if (villf!=0) {
if (vil[1] != 0) {
vil = c(villnames,vil)
}
if (vil[1] == 0) {
vil = villnames
}
}
#save scores
viltraits = filter(src$villains,Group%in%vil)
viltraits[is.na(viltraits)]=0
##############################################################
##Generate henchmen groups
#similar to villains, see above
henchc2 = henchc
henchnames = 0
henchf = 0
hench = 0
#only distinct group names due to the Mandarin and his rings
hmlist=distinct(src$henchmen,Name)
if (!is.na(src$schemes$HM_Inc[schnumber])) {
henchnames[henchf+1] = src$schemes$HM_Inc[schnumber]
henchf = henchf + 1
}
if (!is.na(mmlist$LeadsH[mmnumber])&(henchc-henchf)!=0) {
henchnames[henchf+1] = mmlist$LeadsH[mmnumber]
henchf = henchf + 1
}
henchc2= henchc - henchf
if (henchc2!=0&length(fixedHM)>0) {
for (i in 1:length(fixedHM)) {
if (fixedHM[i]%in%hmlist$Name) {
if (!fixedHM[i]%in%henchnames) {
henchnames[henchf+1] = hmlist$Name[hmlist$Name==fixedHM[i]]
henchf = henchf + 1
}
}
else {
warning("Henchmen - ",fixedHM[i]," - not found")
}
}
if (length(henchnames)>henchc) {
henchnames = henchnames[1:henchc]
}
}
henchc2= henchc - henchf
if (henchc2>0) {
henchmen = filter(hmlist,!Name%in%henchnames)
hench=sample(1:nrow(hmlist),henchc,replace=F)
hench = hmlist$Name[hench]
}
if (henchf!=0) {
if (hench[1] != 0) {
hench = c(henchnames,hench)
}
if (hench[1] == 0) {
hench = henchnames
}
}
henchtraits = filter(src$henchmen,Name%in%hench)
henchtraits[is.na(henchtraits)]=0
##############################################################
##Generate heroes
fixed_heroes = 0
heronames = NULL
#A few schemes have such specific needs their hero requirements are hardcoded here separately
if (schemtraits$Hero_Inc[1]=="CUSTOM") {
schemtraits$Hero_Inc[1] = NA
if (schemtraits$Name[1]=="Avengers vs X-Men") {
teamlist = count(src$heroes,Team)
teamlist %<>% filter(n>12)
teamlist %<>% sample_n(2)
src$heroes %<>% filter(Team%in%teamlist$Team)
fixedHER = NULL
src$heroes$uni = paste(src$heroes$Hero,src$heroes$Set,sep="_")
herolist1 = distinct(filter(src$heroes,Team==teamlist$Team[1]),uni)
herolist2 = distinct(filter(src$heroes,Team==teamlist$Team[2]),uni)
heronumber1 = sample(1:nrow(herolist1),heroesc/2,replace=F)
heronumber2 = sample(1:nrow(herolist2),heroesc/2,replace=F)
heroid1 = herolist1$uni[heronumber1]
heroid2 = herolist2$uni[heronumber2]
heronames = tibble(heroid=c(heroid1,heroid2))
heronames$name=NA
heronames$set=NA
for (i in 1:heroesc) {
heronames$name[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][1]
heronames$set[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][2]
}
heroesc = 0
}
if (schemtraits$Name[1]=="House of M") {
fixedHER = NULL
src$heroes$uni = paste(src$heroes$Hero,src$heroes$Set,sep="_")
herolist1 = distinct(filter(src$heroes,Team=="X-Men"),uni)
herolist2 = distinct(filter(src$heroes,Team!="X-Men"),uni)
heronumber1 = sample(1:nrow(herolist1),4,replace=F)
heronumber2 = sample(1:nrow(herolist2),2,replace=F)
heroid1 = herolist1$uni[heronumber]
heroid2 = herolist2$uni[heronumber]
heronames = tibble(heroid=c(heroid1,heroid2))
heronames$name=NA
heronames$set=NA
for (i in 1:heroesc) {
heronames$name[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][1]
heronames$set[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][2]
}
heroesc = 0
}
}
#hero required by scheme?
if (!is.na(src$schemes$Hero_Inc[schnumber])&
heroesc!=0) {
fixed_heroes[1] = src$schemes$Hero_Inc[schnumber]
}
#disambiguate names by concatening set id
src$heroes$uni = paste(src$heroes$Hero,src$heroes$Set,sep="_")
herolist = distinct(src$heroes,uni)
#check if the provided fixed names can be found
fixedHER2 = fixedHER[fixedHER%in%src$heroes$Hero]
if (length(fixedHER2)<length(fixedHER)) {
warning("Hero(es) ",paste(fixedHER[!fixedHER%in%fixedHER2],collapse=",")," not found.")
}
#join both the scheme hero and the fixed provided (if any)
fixed_heroes = c(fixed_heroes,fixedHER2)
#set up name, set, and concatenated unique id ('heroid')
fixed_heroes = tibble(fixed_heroes)
fixed_heroes$name = fixed_heroes$fixed_heroes
fixed_heroes$set = NA
#remove the dummy row if no hero was part of the sceme requirements
if (fixed_heroes$name[1]==0) {
fixed_heroes = fixed_heroes[-1,]
}
#check required hero count
heroesc2 = heroesc - dim(fixed_heroes)[1]
#if too many heroes now, truncate
if (heroesc2<0) {
fixed_heroes = fixed_heroes[1:heroesc,]
}
#if any fixed heroes, add proper set. randomize if hero with given name in multiple sets
if (dim(fixed_heroes)[1]>0) {
for (i in 1:dim(fixed_heroes)[1]) {
sets = filter(src$heroes,Hero==fixed_heroes$name[i],Ct==1)
if (dim(sets)[1]>1) {
rand = sample(1:dim(sets)[1],1)
fixed_heroes$set[i] = sets$Set[rand]
}
if (dim(sets)[1]==1) {
fixed_heroes$set[i] = sets$Set[1]
}
if (dim(sets)[1]==0) {
warning(paste0("Data error (hero not found): ",fixed_heroes$name[i]))
}
}
}
#add unique heroid
fixed_heroes = select(fixed_heroes,-fixed_heroes)
fixed_heroes$heroid = paste(fixed_heroes$name,fixed_heroes$set,sep="_")
#fill up with random heroes
if (heroesc2>0) {
heronumber = sample(1:nrow(herolist),heroesc2,replace=FALSE)
heroid = herolist$uni[heronumber]
heronames = tibble(heroid)
heronames$name=NA
heronames$set=NA
for (i in 1:heroesc2) {
heronames$name[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][1]
heronames$set[i] = strsplit(as.character(heronames[i,1]),split="_")[[1]][2]
}
}
#join
#only fixed heroes:
if (is.null(heronames)) {
heronames = fixed_heroes
}
#also random ones:
if (!is.null(heronames)) {
heronames = rbind(fixed_heroes,heronames)
}
#save scores
herotraits = filter(src$heroes,uni%in%heronames$heroid)
herotraits[is.na(herotraits)]=0
#list sets
sets = c(heronames$set,
schemtraits$Set,
mmtraits$Set[1],
filter(viltraits,!duplicated(Group))$Set,
filter(henchtraits,!duplicated(Name))$Set)
##Print out results
resu = list(
schem,
mm,
vil,
hench,
heronames$name,
heronames$set,
list(schemtraits,mmtraits,viltraits,henchtraits,herotraits),
sets)
names(resu) = c("Scheme",
"Mastermind",
"Villains",
"Henchmen",
"Heroes",
"Heroes_set",
"scores",
"sets")
names(resu$scores) = c("scheme",
"mastermind",
"villains",
"henchmen",
"heroes")
return(resu)
}
game = genFun(src,fixedSCH="Predict future crime",fixedMM="Stryfe",fixedHM="Sentinel",fixedVIL=c("MLF","Dark-Council","Spider-Friends"),fixedHER=c("Phoenix Force Cylops","Jubilee","Rocket Raccoon","Tigra","Mysterio"))
game = genFun(src,fixedSCH="Predict future crime",fixedMM="Stryfe",fixedHM="Sentinel",fixedVIL=c("MLF","Dark Council","Spider-Friends"),fixedHER=c("Phoenix Force Cyclops","Jubilee","Rocket Raccoon","Tigra","Mysterio"))
knitr::opts_chunk$set(echo = TRUE)
metricsGen = function(games,nr) {
#games is a list of generated setups
#nr is the element of that list to calculate metrics for
#initialize metrics df
bCount = 0
metrics = tibble(bCount)
##colorcounts
#issue if t or split cards with the same color
#does not take into account villains gained as heroes
metrics$bCount =
sum(games[[nr]]$scores$heroes$B*
games[[nr]]$scores$heroes$Ct)
metrics$rCount =
sum(games[[nr]]$scores$heroes$R*
games[[nr]]$scores$heroes$Ct)
metrics$yCount =
sum(games[[nr]]$scores$heroes$Y*
games[[nr]]$scores$heroes$Ct)
metrics$gCount =
sum(games[[nr]]$scores$heroes$G*
games[[nr]]$scores$heroes$Ct)
metrics$sCount =
sum(games[[nr]]$scores$heroes$S*
games[[nr]]$scores$heroes$Ct)
##count color requirements of heroes, villains, mm and scheme
#does not differentiate right now for epic, so slight inflation possible
#might also consider ignoring if both sides of transforming mm care about a certain color
metrics$bReq =
sum(games[[nr]]$scores$heroes$Br*
games[[nr]]$scores$heroes$Ct) +
sum(games[[nr]]$scores$villains$B*
games[[nr]]$scores$villains$Ct) +
sum(games[[nr]]$scores$mastermind$B) +
games[[nr]]$scores$scheme$B
metrics$rReq =
sum(games[[nr]]$scores$heroes$Rr*
games[[nr]]$scores$heroes$Ct) +
sum(games[[nr]]$scores$villains$R*
games[[nr]]$scores$villains$Ct) +
sum(games[[nr]]$scores$mastermind$R) +
games[[nr]]$scores$scheme$R
metrics$yReq =
sum(games[[nr]]$scores$heroes$Yr*
games[[nr]]$scores$heroes$Ct) +
sum(games[[nr]]$scores$villains$Y*
games[[nr]]$scores$villains$Ct) +
sum(games[[nr]]$scores$mastermind$Y) +
games[[nr]]$scores$scheme$Y
metrics$gReq =
sum(games[[nr]]$scores$heroes$Gr*
games[[nr]]$scores$heroes$Ct) +
sum(games[[nr]]$scores$villains$G*
games[[nr]]$scores$villains$Ct) +
sum(games[[nr]]$scores$mastermind$G) +
games[[nr]]$scores$scheme$G
metrics$sReq =
sum(games[[nr]]$scores$heroes$Sr*
games[[nr]]$scores$heroes$Ct) +
sum(games[[nr]]$scores$villains$S*
games[[nr]]$scores$villains$Ct) +
sum(games[[nr]]$scores$mastermind$S) +
games[[nr]]$scores$scheme$S
###cost requirements
#C2 and C4
metrics$C2r = sum(games[[nr]]$scores$heroes$C2*
games[[nr]]$scores$heroes$Ct)
metrics$C2 = sum(filter(games[[nr]]$scores$heroes,C==2)$Ct)
metrics$C4r = sum(games[[nr]]$scores$heroes$C4*
games[[nr]]$scores$heroes$Ct)
metrics$C4 = sum(filter(games[[nr]]$scores$heroes,C==4)$Ct)
##cost diversity
metrics$Cdivr = sum(games[[nr]]$scores$heroes$CD*
games[[nr]]$scores$heroes$Ct)
cost_div = games[[nr]]$scores$heroes %>%
group_by(C) %>%
summarize(sum = sum(Ct))
#using fractions for Shannon and evenness calculations
cost_div$p = cost_div$sum/sum(cost_div$sum)
metrics$Cdiv = -sum(cost_div$p*log(cost_div$p))
metrics$CdivEV = metrics$Cdiv/log(dim(cost_div)[1])
##spectrum
metrics$colorDIVr = sum(games[[nr]]$scores$heroes$SP*
games[[nr]]$scores$heroes$Ct)
colors = c("B","R","Y","G","S")
n = unlist(metrics[1:5])
color_div = tibble(colors,n)
color_div$p = color_div$n/sum(color_div$n)
metrics$colorDIV = -sum(color_div$p*log(color_div$p))
metrics$colorEV = metrics$colorDIV /log(dim(color_div)[1])
##Wounds
metrics$wndsum = sum(games[[nr]]$scores$heroes$Wd*
games[[nr]]$scores$heroes$Ct) +
sum(games[[nr]]$scores$villains$Wnd*
games[[nr]]$scores$villains$Ct) +
games[[nr]]$scores$scheme$Wnd*games[[nr]]$scores$scheme$CT
if (dim(games[[nr]]$scores$mastermind)[1]==5) {
metrics$wndsum = metrics$wndsum +
games[[nr]]$scores$mastermind$Wnd[1]*5 +
sum(games[[nr]]$scores$mastermind$Wnd[2:5])
}
if (dim(games[[nr]]$scores$mastermind)[1]==6) {
metrics$wndsum = metrics$wndsum +
games[[nr]]$scores$mastermind$Wnd[1]*2.5 +
games[[nr]]$scores$mastermind$Wnd[2]*2.5 +
sum(games[[nr]]$scores$mastermind$Wnd[3:6])
}
##KO heroes
games[[nr]]$scores$heroes$KOng = 0
games[[nr]]$scores$heroes$KOng[games[[nr]]$scores$heroes$KO==2] = 1
games[[nr]]$scores$villains$KOng = 0
games[[nr]]$scores$villains$KOng[games[[nr]]$scores$villains$KOH==2] = 1
metrics$kohsum = sum(games[[nr]]$scores$heroes$KOng*
games[[nr]]$scores$heroes$Ct) +
sum(games[[nr]]$scores$villains$KOng*
games[[nr]]$scores$villains$Ct) +
games[[nr]]$scores$scheme$KOH*games[[nr]]$scores$scheme$CT
if (dim(games[[nr]]$scores$mastermind)[1]==5) {
metrics$kohsum = metrics$kohsum +
games[[nr]]$scores$mastermind$KOH[1]*5 +
sum(games[[nr]]$scores$mastermind$KOH[2:5])
}
if (dim(games[[nr]]$scores$mastermind)[1]==6) {
metrics$kohsum = metrics$kohsum +
games[[nr]]$scores$mastermind$KOH[1]*2.5 +
games[[nr]]$scores$mastermind$KOH[2]*2.5 +
sum(games[[nr]]$scores$mastermind$KOH[3:6])
}
##crowding
metrics$crwdsum = sum(games[[nr]]$scores$villains$CRWD*
games[[nr]]$scores$villains$Ct) +
games[[nr]]$scores$scheme$CRWD*games[[nr]]$scores$scheme$CT
if (dim(games[[nr]]$scores$mastermind)[1]==5) {
metrics$crwdsum = metrics$crwdsum +
games[[nr]]$scores$mastermind$CRWD[1]*5 +
sum(games[[nr]]$scores$mastermind$CRWD[2:5])
}
if (dim(games[[nr]]$scores$mastermind)[1]==6) {
metrics$crwdsum = metrics$crwdsum +
games[[nr]]$scores$mastermind$CRWD[1]*2.5 +
games[[nr]]$scores$mastermind$CRWD[2]*2.5 +
sum(games[[nr]]$scores$mastermind$CRWD[3:6])
}
##hencko
#metrics$hencko = sum(games[[nr]]$scores$henchmen$KO_HERO)
##wincon
metrics$wincon = games[[nr]]$scores$scheme$EW
metrics$wincon = plyr::revalue(metrics$wincon,c(
"VE" = "Villains Escaped",
"SE" = paste0(games[[nr]]$scores$scheme$EWH," escaped"),
"WO" = "Wound stack runs out",
"LT" = "Last or second to last twist",
"HK" = "Heroes KO'd",
"O"= "Other"),warn_missing = F)
#MoFi
metrics$MoFir = sum(games[[nr]]$scores$heroes$MF)
metrics$MoFi = sum(filter(games[[nr]]$scores$heroes,MO==1,FI==1)$Ct)
#NoRu
metrics$NoRur = sum(filter(games[[nr]]$scores$heroes,NR==-1)$Ct)
metrics$NoRu = sum(filter(games[[nr]]$scores$heroes,NR==1)$Ct)
#Lightshow
metrics$Lightshow = sum(filter(games[[nr]]$scores$heroes,LS!=0)$Ct*filter(games[[nr]]$scores$heroes,LS!=0)$LS)
metrics$Lightshowr = sum(filter(games[[nr]]$scores$heroes,LS!=0)$Ct)/sum(games[[nr]]$scores$heroes$Ct)
metrics$bDef = metrics$bCount - metrics$bReq
metrics$rDef = metrics$rCount - metrics$rReq
metrics$gDef = metrics$gCount - metrics$gReq
metrics$yDef = metrics$yCount - metrics$yReq
metrics$sDef = metrics$sCount - metrics$sReq
return(metrics)
}
test=metricsGen(game)
test=metricsGen(game,1)
t1 = list(game)
test=metricsGen(t1,1)
View(test)
test$colorDIV
is.nan(test$colorDIV
)
is.na(test$colorDIV)
?colSums
runApp('ledgen')
View(test)
is.na(test$colorDIV)
View(select_if(test,!is.na))
View(select_if(test,!is.na(.)))
?select_if
View(select_if(test,is.na))
View(select_if(test,!is.na))
View(select_if(test,is.na==F))
View(select_if(test,negate(is.na)))
runApp('ledgen')
runApp('ledgen')
runApp('ledgen')
runApp('ledgen')
View(test)
runApp('ledgen')
runApp()
runApp('ledgen')
